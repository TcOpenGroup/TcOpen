<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="TcoDatamanClearResultData_v_5_x_x" Id="{20001709-502a-0419-3be6-fc7096dea873}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK TcoDatamanClearResultData_v_5_x_x EXTENDS TcoCore.TcoTask
VAR_IN_OUT
	inoIoData : TcoDatamanIO_v_5_x_x;
    inoConfig : TcoDatamanConfig_v_5_x_x;
	inoStatus : TcoDatamanStatus_v_5_x_x;	
	inoResultData : TcoDatamanResults_v_5_x_x;
END_VAR
VAR
	_progress : INT := 0;
	_infoTimer :  TON;
	_errorTimer :  TON;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF Execute() THEN
	IF _progress = 0 THEN
		THIS^.inoStatus.ActionDescription := '<#Clearing result data running.#>'; 
		CallTimers(FALSE);
		_progress := _progress + 1;
	END_IF
	
	IF _progress = 1 THEN
		THIS^.inoIoData.AcquisitionControl.TriggerEnable := FALSE;
		THIS^.inoIoData.AcquisitionControl.Trigger := FALSE;
		THIS^.inoIoData.ResultsControl.ResultsAcknowledge := TRUE;
		THIS^.Messenger.OnCondition(_infoTimer.Q).Warning('<#Waiting for the result data cleared!#>');
		THIS^.inoResultData.Length := 0; 
		IF Tc2_System.MEMSET(destAddr:= ADR(THIS^.inoResultData.Data) , fillByte:= 0 , n:= SIZEOF(THIS^.inoResultData.Data)) >0 THEN
			CallTimers(FALSE);
			_progress := _progress + 1;
		END_IF
	END_IF
	
	IF _progress = 2 THEN
		THIS^.Messenger.OnCondition(_infoTimer.Q).Warning('<#Waiting for the signal ResultsAvailable reseted!#>'); 
		IF NOT THIS^.inoIoData.ResultsStatus.ResultsAvailable THEN
			CallTimers(FALSE);
			_progress := _progress + 1;
		END_IF
	END_IF
	
	IF _progress = 3 THEN
		THIS^.inoIoData.ResultsControl.ResultsAcknowledge := FALSE;
		THIS^.DoneWhen(TRUE);
		CallTimers(FALSE);
		_progress := 0;
	END_IF
	
	CallTimers(TRUE);
	
	THIS^.ThrowWhen(_errorTimer.Q);
END_IF
]]></ST>
    </Implementation>
    <Method Name="CallTimers" Id="{798323ce-9b71-0375-2d22-25da22fd5936}">
      <Declaration><![CDATA[METHOD CallTimers
VAR_INPUT
	inValue : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_infoTimer(IN := inValue, PT := THIS^.inoConfig.InfoTime);
_errorTimer(IN := inValue, PT := THIS^.inoConfig.ErrorTime);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="OnAbort" Id="{add0c41f-54c7-073d-3688-e52d5e3af330}">
      <Declaration><![CDATA[(*~
	<docu>
		<summary>
			Executes when task is aborted.
		</summary>			
	</docu>	
~*)
METHOD PROTECTED OnAbort
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.inoStatus.ActionDescription := '<#Clearing result data aborted, while not yet finished.#>'; 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="OnDone" Id="{9a98a140-3258-0df6-3454-7bf1ee96c5dc}">
      <Declaration><![CDATA[(*~
	<docu>
		<summary>
			Executes when task reaches the ```Done``` state .
		</summary>			
	</docu>	
~*)
METHOD PROTECTED OnDone
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.inoStatus.ActionDescription := '<#Clearing result data done succesfull.#>'; 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="OnError" Id="{4cfb1cfa-ec61-0d21-357d-50a02d75820c}">
      <Declaration><![CDATA[(*~
	<docu>
		<summary>
			Executes when task reaches the ```Error``` state.
			<para>
				Do not confuse with <see cref="PlcDocu.TcoCore.TcoTask.WhileError()"/>, that is called cyclically until '''Error''' state is left.
			</para>
		</summary>			
	</docu>	
~*)
METHOD PROTECTED OnError
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.inoStatus.ActionDescription := '<#Clearing result data finished with error.#>'; 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="OnStart" Id="{154dcb23-1283-07e8-267d-8221e4e6c1cd}">
      <Declaration><![CDATA[METHOD PROTECTED OnStart 
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.inoStatus.ActionDescription := '<#Clearing result data started.#>'; 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Restore" Id="{b28c3390-b4e1-00c7-17c4-843c0c4b7072}">
      <Declaration><![CDATA[(*~
	<docu>
		<summary>
			Restores this instance to the Ready state. Can be called explicitly or from within one of the restore mechanisms.
			<para>
				See also <see cref="PlcDocu.TcoCore.TcoTask.AutoRestorable()"/>
			</para>
		</summary>			
	</docu>	
~*)
METHOD Restore : ITcoRestorable]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Restore();
_progress := 0;
CallTimers(FALSE);]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>