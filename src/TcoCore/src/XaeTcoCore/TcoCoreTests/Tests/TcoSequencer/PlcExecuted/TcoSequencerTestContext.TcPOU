<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="TcoSequencerTestContext" Id="{4e7acbde-4743-0cad-2bb0-27aaf0a30196}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK TcoSequencerTestContext EXTENDS TcoCore._internals_TcoContext
VAR
    _sut_A : TcoSequencerTestType(THIS^,eRestoreMode.AutoRestoreMembers);
    _sut_N : TcoSequencerTestType(THIS^,eRestoreMode.None);
(*	_to_A : TcoTaskPlcTestObject(THIS^);
	_to_B : TcoTaskPlcTestObject(THIS^);*)
    _elapsedTimeETA : TIME;
    _elapsedTime : TIME;
    _runElapsedTimer : BOOL;
    _elapsedTimeTimer : Tc2_Standard.TON;
    _inBool : BOOL;
    _inUint : UINT;
    _inInt : INT;
    _inString : STRING;
    _retBool : BOOL;
    _retUint : UINT;
    _retInt : INT;
    _retString : STRING;
    _done : BOOL;
    _arranged : BOOL;
	_startCycles			:	ULINT;
	_endCycles				:	ULINT;	
	_myIdentity				:	ULINT;	
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[
]]></ST>
    </Implementation>
    <Method Name="_ClearPlcCycleCounter" Id="{274d460c-6ba5-08a4-1274-ae55b3782f20}">
      <Declaration><![CDATA[{attribute 'TcRpcEnable'}
METHOD _ClearPlcCycleCounter
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ClearPlcCycleCounter();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Main" Id="{7bce61db-8c18-0228-0437-a852b9614763}">
      <Declaration><![CDATA[METHOD PROTECTED Main

]]></Declaration>
      <Implementation>
        <ST><![CDATA[_elapsedTimeTimer(IN := _runElapsedTimer, PT := _elapsedTimeETA);

CASE _testId OF
    {region "CallSequencerBodiesOnly"}
    eTcoSequencerTests.CallSequencerBodiesOnly:
        _sut_A.TcoSequencerTest := eTcoSequencerTests.CallSequencerBodiesOnly;
        _sut_N.TcoSequencerTest := eTcoSequencerTests.CallSequencerBodiesOnly;
        _sut_A.Run();
        _sut_N.Run();
    {endregion}
    {region "RestoreSequencers"}
    eTcoSequencerTests.RestoreSequencers:
        IF NOT _arranged THEN
            _sut_A.Restore();
            _sut_N.Restore();
            _arranged := _sut_A._restoringSequence AND _sut_N._restoringSequence;
        END_IF

        IF _arranged AND NOT _done THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.RestoreSequencers;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.RestoreSequencers;
            _sut_A.Run();
            _sut_N.Run();

            _done :=
                NOT _sut_A._restoringSequence AND NOT _sut_N._restoringSequence AND NOT _sut_A._sequencerHasError AND NOT _sut_N._sequencerHasError;
        END_IF

        ProbeDoneWhen(_done);
    {endregion}
    {region "T500_NumberOfStepsCount"}
    eTcoSequencerTests.NumberOfStepsCount:
        IF NOT _arranged THEN
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.ClearNumberOfSteps(); //Clear internal flow step counters, so number of steps is going to be counted again on next sequence run
            _sut_N.ClearNumberOfSteps(); //Clear internal flow step counters, so number of steps is going to be counted again on next sequence run
            _sut_A.SetCurrentStep(_inInt, _inString); //Set the StepId so as the StepDescription to the current step of the sequencer
            _sut_N.SetCurrentStep(_inInt, _inString); //Set the StepId so as the StepDescription to the current step of the sequencer
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.TcoSequencerTest := eTcoSequencerTests.NumberOfStepsCount;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.NumberOfStepsCount;
            _sut_A.TotalStepNumber := _inUint;
            _sut_N.TotalStepNumber := _inUint;
            _sut_A.FinishStep := FALSE;
            _sut_N.FinishStep := FALSE;

            _arranged := _inInt = _sut_A._currentStepId AND
                _inString = _sut_A._currentStepDescription AND
                _inInt = _sut_N._currentStepId AND
                _inString = _sut_N._currentStepDescription;

            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _done := TRUE;
        END_IF

        IF _done THEN
            ProbeDoneWhen(_done);
        END_IF
    {endregion}
    {region "T501_ExecutionInOnePLCcycle"}
    eTcoSequencerTests.ExecutionInOnePLCcycle:
        _sut_A.TcoSequencerTest := eTcoSequencerTests.ExecutionInOnePLCcycle;
        _sut_N.TcoSequencerTest := eTcoSequencerTests.ExecutionInOnePLCcycle;
        _sut_A.TotalStepNumber := _inUint;
        _sut_N.TotalStepNumber := _inUint;
        _sut_A.Run();
        _sut_N.Run();
        _sut_A.UpdateCurrentStepDetails();
        _sut_N.UpdateCurrentStepDetails();
        _done := TRUE;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T502_OnStepCompleted"}
    eTcoSequencerTests.OnStepCompleted:
        _sut_A.TcoSequencerTest := eTcoSequencerTests.OnStepCompleted;
        _sut_N.TcoSequencerTest := eTcoSequencerTests.OnStepCompleted;
        _sut_A.TotalStepNumber := _inUint;
        _sut_N.TotalStepNumber := _inUint;
        _sut_A.Run();
        _sut_N.Run();
        _sut_A.SaveNumberOfStepsInSequence();
        _sut_N.SaveNumberOfStepsInSequence();
        _done := TRUE;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T503_OnSequenceCompleted"}
    eTcoSequencerTests.OnSequenceCompleted:
        _sut_A.TcoSequencerTest := eTcoSequencerTests.OnSequenceCompleted;
        _sut_N.TcoSequencerTest := eTcoSequencerTests.OnSequenceCompleted;
        _sut_A.TotalStepNumber := _inUint;
        _sut_N.TotalStepNumber := _inUint;
        _sut_A.Run();
        _sut_N.Run();
        _done := TRUE;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T504_RestoreChildBetweenSteps"}
    eTcoSequencerTests.RestoreChildBetweenSteps:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.RestoreChildBetweenSteps;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.RestoreChildBetweenSteps;
            _sut_A.TotalStepNumber := _inUint;
            _sut_N.TotalStepNumber := _inUint;
            _arranged := TRUE;
            RETURN;
        END_IF;

        _sut_A.Run();
        _sut_N.Run();
        _done := TRUE;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T505_OnStateChangeWithRestoreCallInside"}
    eTcoSequencerTests.OnStateChangeWithRestoreCallInside:
        IF NOT _arranged THEN
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.SetNumberOfSteps(_inUint); //Set numberOfSteps to the testing instance
            _sut_N.SetNumberOfSteps(_inUint); //Set numberOfSteps to the testing instance
            _sut_A.TcoSequencerTest := eTcoSequencerTests.OnStateChangeWithRestoreCallInside;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.OnStateChangeWithRestoreCallInside;
            _sut_A.TotalStepNumber := _inUint;
            _sut_N.TotalStepNumber := _inUint;
            _sut_A.FinishStep := FALSE;
            _sut_N.FinishStep := FALSE;
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            IF _plcCycleCounter = 1 THEN
                _sut_A.CallRestoreInOnStateChange := FALSE;
                _sut_N.CallRestoreInOnStateChange := FALSE;
            ELSE
                _sut_A.CallRestoreInOnStateChange := TRUE;
                _sut_N.CallRestoreInOnStateChange := TRUE;
                _sut_A.FinishStep := TRUE;
                _sut_N.FinishStep := TRUE;
            END_IF

            _sut_A.Run();
            _sut_N.Run();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := _plcCycleCounter >= 2;

        IF _done THEN
            _sut_A.CallRestoreInOnStateChange := FALSE;
            _sut_N.CallRestoreInOnStateChange := FALSE;
            ProbeDoneWhen(_done);
        END_IF
    {endregion}
    {region "T506_MinStepId"}
    eTcoSequencerTests.MinStepId:
        IF NOT _arranged THEN
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.SetNumberOfSteps(_inUint); //Set numberOfSteps to the testing instance
            _sut_N.SetNumberOfSteps(_inUint); //Set numberOfSteps to the testing instance
            _sut_A.TcoSequencerTest := eTcoSequencerTests.MinStepId;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.MinStepId;
            _sut_A.TotalStepNumber := _inUint;
            _sut_N.TotalStepNumber := _inUint;
            _sut_A.FinishStep := FALSE;
            _sut_N.FinishStep := FALSE;
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.StepId := _inInt;
            _sut_N.StepId := _inInt;
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := TRUE;
        ProbeDoneWhen(_done);
{endregion}
    {region "T507_MaxStepId"}
    eTcoSequencerTests.MaxStepId:
        IF NOT _arranged THEN
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.SetNumberOfSteps(_inUint); //Set numberOfSteps to the testing instance
            _sut_N.SetNumberOfSteps(_inUint); //Set numberOfSteps to the testing instance
            _sut_A.TcoSequencerTest := eTcoSequencerTests.MaxStepId;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.MaxStepId;
            _sut_A.TotalStepNumber := _inUint;
            _sut_N.TotalStepNumber := _inUint;
            _sut_A.FinishStep := FALSE;
            _sut_N.FinishStep := FALSE;
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.StepId := _inInt;
            _sut_N.StepId := _inInt;
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := TRUE;
        ProbeDoneWhen(_done);
{endregion}


END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadOutCycleCounters" Id="{1913803e-85aa-00c3-3eb7-a30f031b63c4}">
      <Declaration><![CDATA[METHOD INTERNAL ReadOutCycleCounters]]></Declaration>
      <Implementation>
        <ST><![CDATA[_startCycles		:=		THIS^.StartCycleCount;
_endCycles			:=		THIS^.EndCycleCount;

_myIdentity			:= 		THIS^.Identity;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>