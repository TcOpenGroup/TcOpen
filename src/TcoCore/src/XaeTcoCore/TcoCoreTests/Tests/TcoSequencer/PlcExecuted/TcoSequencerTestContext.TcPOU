<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="TcoSequencerTestContext" Id="{4e7acbde-4743-0cad-2bb0-27aaf0a30196}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK TcoSequencerTestContext EXTENDS TcoCore._internals_TcoContext
VAR
    _sut_A : TcoSequencerTestType(THIS^,eRestoreMode.AutoRestoreMembers);
    _sut_N : TcoSequencerTestType(THIS^,eRestoreMode.None);

    _elapsedTimeETA : TIME;
    _elapsedTime : TIME;
    _runElapsedTimer : BOOL;
    _elapsedTimeTimer : Tc2_Standard.TON;

	_runOneStep							:	BOOL;
	_runAllSteps						:	BOOL;
	_finishStep							:	BOOL;
	_stepId								:	INT;
	_enabled							:	BOOL;
	_stepDescription					:	STRING(254);	
	_currentStepId						:	INT;
	_currentStepOrder					:	UINT;
	_currentStepEnabled					:	BOOL;
	_currentStepDescription				:	STRING(254);
	_currentStepStatus					:	INT;
    _totalStepNumber : UINT;
	_reqStep : INT;
    _reqStepNotExists : INT;

    _done : BOOL;
    _arranged : BOOL;
	_startCycles			:	ULINT;
	_endCycles				:	ULINT;	
	_myIdentity				:	ULINT;	
	_initReqStepCycle		:	UINT;
	_cycles					:	UINT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[
]]></ST>
    </Implementation>
    <Method Name="_ClearPlcCycleCounter" Id="{274d460c-6ba5-08a4-1274-ae55b3782f20}">
      <Declaration><![CDATA[{attribute 'TcRpcEnable'}
METHOD _ClearPlcCycleCounter
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ClearPlcCycleCounter();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Main" Id="{7bce61db-8c18-0228-0437-a852b9614763}">
      <Declaration><![CDATA[METHOD PROTECTED Main
VAR
	i:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_elapsedTimeTimer(IN := _runElapsedTimer, PT := _elapsedTimeETA);

CASE _testId OF
    {region "CallSequencerBodiesOnly"}
    eTcoSequencerTests.CallSequencerBodiesOnly:
        _sut_A.TcoSequencerTest := eTcoSequencerTests.CallSequencerBodiesOnly;
        _sut_N.TcoSequencerTest := eTcoSequencerTests.CallSequencerBodiesOnly;
        _sut_A.Run();
        _sut_N.Run();
    {endregion}
    {region "RestoreSequencers"}
    eTcoSequencerTests.RestoreSequencers:
        IF NOT _arranged THEN
            _sut_A.Restore();
            _sut_N.Restore();
            _arranged := _sut_A._restoringSequence AND _sut_N._restoringSequence;
        END_IF

        IF _arranged AND NOT _done THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.RestoreSequencers;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.RestoreSequencers;
            _sut_A.Run();
            _sut_N.Run();

            _done :=
                NOT _sut_A._restoringSequence AND NOT _sut_N._restoringSequence AND NOT _sut_A._sequencerHasError AND NOT _sut_N._sequencerHasError;
        END_IF

        ProbeDoneWhen(_done);
    {endregion}
    {region "T500_NumberOfStepsCount"}
    eTcoSequencerTests.NumberOfStepsCount:
        IF NOT _arranged THEN
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.ClearNumberOfSteps(); //Clear internal flow step counters, so number of steps is going to be counted again on next sequence run
            _sut_N.ClearNumberOfSteps(); //Clear internal flow step counters, so number of steps is going to be counted again on next sequence run

            _sut_A.SetCurrentStep(_currentStepId,
                _currentStepDescription); //Set the StepId so as the StepDescription to the current step of the sequencer

            _sut_N.SetCurrentStep(_currentStepId,
                _currentStepDescription); //Set the StepId so as the StepDescription to the current step of the sequencer

            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.TcoSequencerTest := eTcoSequencerTests.NumberOfStepsCount;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.NumberOfStepsCount;
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.FinishStep := FALSE;
            _sut_N.FinishStep := FALSE;

            _arranged := _currentStepId = _sut_A._currentStepId AND
                _currentStepDescription = _sut_A._currentStepDescription AND
                _currentStepId = _sut_N._currentStepId AND
                _currentStepDescription = _sut_N._currentStepDescription;

            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _done := TRUE;
        END_IF

        IF _done THEN
            ProbeDoneWhen(_done);
        END_IF
    {endregion}
    {region "T501_ExecutionInOnePLCcycle"}
    eTcoSequencerTests.ExecutionInOnePLCcycle:
        _sut_A.TcoSequencerTest := eTcoSequencerTests.ExecutionInOnePLCcycle;
        _sut_N.TcoSequencerTest := eTcoSequencerTests.ExecutionInOnePLCcycle;
        _sut_A.TotalStepNumber := _totalStepNumber;
        _sut_N.TotalStepNumber := _totalStepNumber;
        _sut_A.Run();
        _sut_N.Run();
        _sut_A.UpdateCurrentStepDetails();
        _sut_N.UpdateCurrentStepDetails();
        _done := TRUE;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T502_OnStepCompleted"}
    eTcoSequencerTests.OnStepCompleted:
        _sut_A.TcoSequencerTest := eTcoSequencerTests.OnStepCompleted;
        _sut_N.TcoSequencerTest := eTcoSequencerTests.OnStepCompleted;
        _sut_A.TotalStepNumber := _totalStepNumber;
        _sut_N.TotalStepNumber := _totalStepNumber;
        _sut_A.Run();
        _sut_N.Run();
        _sut_A.SaveNumberOfStepsInSequence();
        _sut_N.SaveNumberOfStepsInSequence();
        _done := TRUE;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T503_OnSequenceCompleted"}
    eTcoSequencerTests.OnSequenceCompleted:
        _sut_A.TcoSequencerTest := eTcoSequencerTests.OnSequenceCompleted;
        _sut_N.TcoSequencerTest := eTcoSequencerTests.OnSequenceCompleted;
        _sut_A.TotalStepNumber := _totalStepNumber;
        _sut_N.TotalStepNumber := _totalStepNumber;
        _sut_A.Run();
        _sut_N.Run();
        _done := TRUE;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T504_RestoreChildBetweenSteps"}
    eTcoSequencerTests.RestoreChildBetweenSteps:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.RestoreChildBetweenSteps;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.RestoreChildBetweenSteps;
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _arranged := TRUE;
            RETURN;
        END_IF;

        _sut_A.Run();
        _sut_N.Run();
        _done := TRUE;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T505_OnStateChangeWithRestoreCallInside"}
    eTcoSequencerTests.OnStateChangeWithRestoreCallInside:
        IF NOT _arranged THEN
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.SetNumberOfSteps(_totalStepNumber); //Set numberOfSteps to the testing instance
            _sut_N.SetNumberOfSteps(_totalStepNumber); //Set numberOfSteps to the testing instance
            _sut_A.TcoSequencerTest := eTcoSequencerTests.OnStateChangeWithRestoreCallInside;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.OnStateChangeWithRestoreCallInside;
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.FinishStep := FALSE;
            _sut_N.FinishStep := FALSE;
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            IF _plcCycleCounter = 1 THEN
                _sut_A.CallRestoreInOnStateChange := FALSE;
                _sut_N.CallRestoreInOnStateChange := FALSE;
            ELSE
                _sut_A.CallRestoreInOnStateChange := TRUE;
                _sut_N.CallRestoreInOnStateChange := TRUE;
                _sut_A.FinishStep := TRUE;
                _sut_N.FinishStep := TRUE;
            END_IF

            _sut_A.Run();
            _sut_N.Run();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := _plcCycleCounter >= 2;

        IF _done THEN
            _sut_A.CallRestoreInOnStateChange := FALSE;
            _sut_N.CallRestoreInOnStateChange := FALSE;
            ProbeDoneWhen(_done);
        END_IF
    {endregion}
    {region "T506_MinStepId"}
    eTcoSequencerTests.MinStepId:
        IF NOT _arranged THEN
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.SetNumberOfSteps(_totalStepNumber); //Set numberOfSteps to the testing instance
            _sut_N.SetNumberOfSteps(_totalStepNumber); //Set numberOfSteps to the testing instance
            _sut_A.TcoSequencerTest := eTcoSequencerTests.MinStepId;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.MinStepId;
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.FinishStep := FALSE;
            _sut_N.FinishStep := FALSE;
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.StepId := _currentStepId;
            _sut_N.StepId := _currentStepId;
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := TRUE;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T507_MaxStepId"}
    eTcoSequencerTests.MaxStepId:
        IF NOT _arranged THEN
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.SetNumberOfSteps(_totalStepNumber); //Set numberOfSteps to the testing instance
            _sut_N.SetNumberOfSteps(_totalStepNumber); //Set numberOfSteps to the testing instance
            _sut_A.TcoSequencerTest := eTcoSequencerTests.MaxStepId;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.MaxStepId;
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.FinishStep := FALSE;
            _sut_N.FinishStep := FALSE;
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.StepId := _currentStepId;
            _sut_N.StepId := _currentStepId;
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := TRUE;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T508_RequestStepToFirstStepWithStepId0"}
    eTcoSequencerTests.RequestStepToFirstStepWithStepId0:
        IF NOT _arranged THEN
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.SetNumberOfSteps(_totalStepNumber); //Set numberOfSteps to the testing instance
            _sut_N.SetNumberOfSteps(_totalStepNumber); //Set numberOfSteps to the testing instance
            _sut_A.TcoSequencerTest := eTcoSequencerTests.RequestStepToFirstStepWithStepId0;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.RequestStepToFirstStepWithStepId0;
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.FinishStep := TRUE;
            _sut_N.FinishStep := TRUE;
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            IF _plcCycleCounter > 1 THEN
                _sut_A.FinishStep := FALSE;
                _sut_N.FinishStep := FalsE;
            END_IF

            _sut_A.Run();
            _sut_N.Run();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := _plcCycleCounter > 1;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T509_RequestStep"}
    eTcoSequencerTests.RequestStep:
        IF NOT _arranged THEN
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.SetNumberOfSteps(10); //Set numberOfSteps to the testing instance
            _sut_N.SetNumberOfSteps(10); //Set numberOfSteps to the testing instance
            _sut_A.TcoSequencerTest := eTcoSequencerTests.RequestStep;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.RequestStep;
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.SequenceRun := _plcCycleCounter;
            _sut_N.SequenceRun := _plcCycleCounter;
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := _plcCycleCounter >= 3;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T510_CheckStepIdUniqueness"}
    eTcoSequencerTests.CheckStepIdUniqueness:
        IF NOT _arranged THEN
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsNotChecked(); //Set sequence as not checked, so StepId uniqueness is going to be performed on next sequence run
            _sut_N.SetSequenceAsNotChecked(); //Set sequence as not checked, so StepId uniqueness is going to be performed on next sequence run
            _sut_A.ClearNumberOfSteps(); //Clear internal step counters, so number of steps is going to be counted again on next sequence run
            _sut_N.ClearNumberOfSteps(); //Clear internal step counters, so number of steps is going to be counted again on next sequence run
            _sut_A.Enabled := TRUE;
            _sut_A.RunOneStep := FALSE;
            _sut_A.RunAllSteps := TRUE;
            _sut_A.FinishStep := TRUE;
            _sut_N.Enabled := TRUE;
            _sut_N.RunOneStep := FALSE;
            _sut_N.RunAllSteps := TRUE;
            _sut_N.FinishStep := TRUE;
            _sut_A.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_N.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_A.TcoSequencerTest := eTcoSequencerTests.CheckStepIdUniqueness;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.CheckStepIdUniqueness;
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
        END_IF

        _done := _plcCycleCounter >= 2;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T512_RestoreAlreadyCheckedSequence"}
    eTcoSequencerTests.RestoreAlreadyCheckedSequence:
        _sut_A.Restore();
        _sut_N.Restore();
        _sut_A.SaveNumberOfStepsInSequence();
        _sut_N.SaveNumberOfStepsInSequence();
        _done := TRUE;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T513_CheckStepIdUniqueness"}
    eTcoSequencerTests.NotUniqueStepId:
        IF NOT _arranged THEN
            _sut_A.Enabled := TRUE;
            _sut_A.RunOneStep := FALSE;
            _sut_A.RunAllSteps := FALSE;
            _sut_A.FinishStep := TRUE;
            _sut_A.StepId := _stepId;
            _sut_N.Enabled := TRUE;
            _sut_N.RunOneStep := FALSE;
            _sut_N.RunAllSteps := FALSE;
            _sut_N.FinishStep := TRUE;
            _sut_N.StepId := _stepId;
            _sut_A.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_N.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_A.TcoSequencerTest := eTcoSequencerTests.NotUniqueStepId;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.NotUniqueStepId;
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _done := _plcCycleCounter >= 2;
        END_IF

        IF _done THEN
            ProbeDoneWhen(_done);
        END_IF
    {endregion}
    {region "T516_AfterErrorRestore"}
    eTcoSequencerTests.AfterErrorRestore:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.AfterErrorRestore;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.AfterErrorRestore;
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _done := _plcCycleCounter >= 3;
        END_IF

        IF _done THEN
            ProbeDoneWhen(_done);
        END_IF
    {endregion}
    {region "T520_ChangeStepIdDuringExecution"}
    eTcoSequencerTests.ChangeStepIdDuringExecution:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.ChangeStepIdDuringExecution;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.ChangeStepIdDuringExecution;
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.ClearNumberOfSteps(); //Clear internal step counters, so number of steps is going to be counted again on next sequence run
            _sut_N.ClearNumberOfSteps(); //Clear internal step counters, so number of steps is going to be counted again on next sequence run
            _sut_A.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_N.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.SequenceRun := _plcCycleCounter;
            _sut_N.SequenceRun := _plcCycleCounter;
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := _plcCycleCounter >= 3;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T524_CommentOutPartOfRunningSequencer"}
    eTcoSequencerTests.CommentOutPartOfRunningSequencer:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.CommentOutPartOfRunningSequencer;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.CommentOutPartOfRunningSequencer;
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.ClearNumberOfSteps(); //Clear internal step counters, so number of steps is going to be counted again on next sequence run
            _sut_N.ClearNumberOfSteps(); //Clear internal step counters, so number of steps is going to be counted again on next sequence run
            _sut_A.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_N.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            IF _plcCycleCounter = 3 THEN
                _sut_A.Restore();
                _sut_N.Restore();
                _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
                _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
                _sut_A.ClearNumberOfSteps(); //Clear internal step counters, so number of steps is going to be counted again on next sequence run
                _sut_N.ClearNumberOfSteps(); //Clear internal step counters, so number of steps is going to be counted again on next sequence run
            END_IF

            _sut_A.SequenceRun := _plcCycleCounter;
            _sut_N.SequenceRun := _plcCycleCounter;
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := _plcCycleCounter >= 3;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T526_UncommentPartOfRunningSequencer"}
    eTcoSequencerTests.UncommentPartOfRunningSequencer:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.UncommentPartOfRunningSequencer;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.UncommentPartOfRunningSequencer;
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.ClearNumberOfSteps(); //Clear internal step counters, so number of steps is going to be counted again on next sequence run
            _sut_N.ClearNumberOfSteps(); //Clear internal step counters, so number of steps is going to be counted again on next sequence run
            _sut_A.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_N.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.SequenceRun := _plcCycleCounter;
            _sut_N.SequenceRun := _plcCycleCounter;
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := _plcCycleCounter >= 2;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T530_OpenCloseSequence"}
    eTcoSequencerTests.OpenCloseSequence:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.OpenCloseSequence;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.OpenCloseSequence;
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.ClearNumberOfSteps(); //Clear internal step counters, so number of steps is going to be counted again on next sequence run
            _sut_N.ClearNumberOfSteps(); //Clear internal step counters, so number of steps is going to be counted again on next sequence run
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            IF _plcCycleCounter = 1 THEN
                _sut_A.SequencerOpen();
                _sut_N.SequencerOpen();

                IF _sut_A._Step(0, TRUE, 'Step 0') THEN
                    _sut_A._StepCompleteWhen(TRUE);
                END_IF

                IF _sut_N._Step(0, TRUE, 'Step 0') THEN
                    _sut_N._StepCompleteWhen(TRUE);
                END_IF
            END_IF

            IF _plcCycleCounter = 2 THEN
                FOR i := 1 TO _totalStepNumber DO
                    _sut_A._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i)));
                    _sut_N._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i)));
                END_FOR

                _sut_A.SequencerClose();
                _sut_N.SequencerClose();
            END_IF

            IF _plcCycleCounter = 3 THEN
                _sut_A.SequencerOpen();
                _sut_N.SequencerOpen();
            END_IF

            IF _plcCycleCounter = 4 THEN
                IF _sut_A._Step(0, TRUE, 'Step 0') THEN
                    _sut_A._StepCompleteWhen(TRUE);
                END_IF

                IF _sut_N._Step(0, TRUE, 'Step 0') THEN
                    _sut_N._StepCompleteWhen(TRUE);
                END_IF
            END_IF

            IF _plcCycleCounter = 5 THEN
                FOR i := 1 TO _totalStepNumber DO
                    IF _sut_A._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i))) THEN
                        _sut_A._StepCompleteWhen(TRUE);
                    END_IF

                    IF _sut_N._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i))) THEN
                        _sut_N._StepCompleteWhen(TRUE);
                    END_IF
                END_FOR
            END_IF

            IF _plcCycleCounter = 6 THEN
                _sut_A._SequenceComplete();
                _sut_N._SequenceComplete();
                _sut_A.SequencerClose();
                _sut_N.SequencerClose();
            END_IF

            IF _plcCycleCounter = 7 THEN
                _sut_A.SequencerOpen();
                _sut_N.SequencerOpen();
            END_IF

            IF _plcCycleCounter = 8 THEN
                _sut_A.SequencerClose();
                _sut_N.SequencerClose();
            END_IF

            IF _plcCycleCounter = 9 THEN
                _sut_A.SequencerOpen();
                _sut_N.SequencerOpen();
                _sut_A._Step(0, TRUE, 'Step 0');
                _sut_N._Step(0, TRUE, 'Step 0');
                _sut_A.SequencerClose();
                _sut_N.SequencerClose();
            END_IF
        END_IF

        _sut_A.UpdateCurrentStepDetails();
        _sut_N.UpdateCurrentStepDetails();
        _done := _plcCycleCounter >= 9;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T541_RequestStepFromLowerToHigher"}
    eTcoSequencerTests.RequestStepFromLowerToHigher:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.RequestStepFromLowerToHigher;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.RequestStepFromLowerToHigher;
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.ClearNumberOfSteps(); //Clear internal step counters, so number of steps is going to be counted again on next sequence run
            _sut_N.ClearNumberOfSteps(); //Clear internal step counters, so number of steps is going to be counted again on next sequence run
            _sut_A.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_N.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.ReqStep := _reqStep;
            _sut_N.ReqStep := _reqStep;
            _sut_A.ReqStepNotExists := _reqStepNotExists;
            _sut_N.ReqStepNotExists := _reqStepNotExists;
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.SequenceRun := _plcCycleCounter;
            _sut_N.SequenceRun := _plcCycleCounter;
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := _plcCycleCounter >= 2;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T542_RequestStepFromHigherToLower"}
    eTcoSequencerTests.RequestStepFromHigherToLower:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.RequestStepFromHigherToLower;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.RequestStepFromHigherToLower;
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.SetNumberOfSteps(_totalStepNumber);
            _sut_N.SetNumberOfSteps(_totalStepNumber);
            _sut_A.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_N.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.ReqStep := _reqStep;
            _sut_N.ReqStep := _reqStep;
            _sut_A.ReqStepNotExists := _reqStepNotExists;
            _sut_N.ReqStepNotExists := _reqStepNotExists;
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.SequenceRun := _plcCycleCounter;
            _sut_N.SequenceRun := _plcCycleCounter;
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := _plcCycleCounter >= 2;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T544_RequestStepToNotExistingStep"}
    eTcoSequencerTests.RequestStepToNotExistingStep:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.RequestStepToNotExistingStep;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.RequestStepToNotExistingStep;
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.SetNumberOfSteps(_totalStepNumber);
            _sut_N.SetNumberOfSteps(_totalStepNumber);
            _sut_A.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_N.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.ReqStep := _reqStep;
            _sut_N.ReqStep := _reqStep;
            _sut_A.ReqStepNotExists := _reqStepNotExists;
            _sut_N.ReqStepNotExists := _reqStepNotExists;
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.SequenceRun := _plcCycleCounter;
            _sut_N.SequenceRun := _plcCycleCounter;
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := _plcCycleCounter >= 3;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T547_RequestStepWhilePreviousRequestStepHasNotBeenYetProcessed"}
    eTcoSequencerTests.RequestStepWhilePreviousRequestStepHasNotBeenYetProcessed:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.RequestStepWhilePreviousRequestStepHasNotBeenYetProcessed;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.RequestStepWhilePreviousRequestStepHasNotBeenYetProcessed;
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.SetNumberOfSteps(_totalStepNumber);
            _sut_N.SetNumberOfSteps(_totalStepNumber);
            _sut_A.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_N.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.ReqStep := _reqStep;
            _sut_N.ReqStep := _reqStep;
            _sut_A.ReqStepNotExists := _reqStepNotExists;
            _sut_N.ReqStepNotExists := _reqStepNotExists;
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.SequenceRun := _plcCycleCounter;
            _sut_N.SequenceRun := _plcCycleCounter;
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := TRUE;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T551_DisableStepEnabledAndActiveInPreviousPLCcycle"}
    eTcoSequencerTests.DisableStepEnabledAndActiveInPreviousPLCcycle:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.DisableStepEnabledAndActiveInPreviousPLCcycle;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.DisableStepEnabledAndActiveInPreviousPLCcycle;
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.SetNumberOfSteps(_totalStepNumber);
            _sut_N.SetNumberOfSteps(_totalStepNumber);
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            IF _plcCycleCounter = 1 THEN
                _sut_A.SequencerOpen();

                IF _sut_A._Step(0, TRUE, 'Step 0') THEN
                    _sut_A._StepCompleteWhen(TRUE);
                END_IF

                FOR i := 1 TO _totalStepNumber - 1 DO
                    _sut_A._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i)));
                END_FOR

                IF _sut_A._Step(_totalStepNumber, TRUE, CONCAT('Step ', INT_TO_STRING(_totalStepNumber))) THEN
                    _sut_A._SequenceComplete();
                END_IF

                _sut_A.SequencerClose();
                _sut_N.SequencerOpen();

                IF _sut_N._Step(0, TRUE, 'Step 0') THEN
                    _sut_N._StepCompleteWhen(TRUE);
                END_IF

                FOR i := 1 TO _totalStepNumber - 1 DO
                    _sut_N._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i)));
                END_FOR

                IF _sut_N._Step(_totalStepNumber, TRUE, CONCAT('Step ', INT_TO_STRING(_totalStepNumber))) THEN
                    _sut_N._SequenceComplete();
                END_IF

                _sut_N.SequencerClose();
            END_IF

            IF _plcCycleCounter = 2 THEN
                _sut_A.SequencerOpen();

                IF _sut_A._Step(0, TRUE, 'Step 0') THEN
                    _sut_A._StepCompleteWhen(TRUE);
                END_IF

                IF _sut_A._Step(1, FALSE, 'Step 0') THEN
                    _sut_A._StepCompleteWhen(FALSE);
                END_IF

                _sut_N.SequencerOpen();

                IF _sut_N._Step(0, TRUE, 'Step 0') THEN
                    _sut_N._StepCompleteWhen(TRUE);
                END_IF

                IF _sut_N._Step(1, FALSE, 'Step 0') THEN
                    _sut_N._StepCompleteWhen(FALSE);
                END_IF
            END_IF

            IF _plcCycleCounter = 3 THEN
                FOR i := 2 TO _totalStepNumber - 1 DO
                    _sut_A._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i)));
                END_FOR

                IF _sut_A._Step(_totalStepNumber, TRUE, CONCAT('Step ', INT_TO_STRING(_totalStepNumber))) THEN
                    _sut_A._SequenceComplete();
                END_IF

                _sut_A.SequencerClose();

                FOR i := 2 TO _totalStepNumber - 1 DO
                    _sut_N._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i)));
                END_FOR

                IF _sut_N._Step(_totalStepNumber, TRUE, CONCAT('Step ', INT_TO_STRING(_totalStepNumber))) THEN
                    _sut_N._SequenceComplete();
                END_IF

                _sut_N.SequencerClose();
            END_IF

            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := _plcCycleCounter >= 3;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T560_RequestStepCallingCyclically"}
    eTcoSequencerTests.RequestStepCallingCyclically:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.RequestStepCallingCyclically;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.RequestStepCallingCyclically;
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.SetNumberOfSteps(_totalStepNumber);
            _sut_N.SetNumberOfSteps(_totalStepNumber);
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.InitReqStepCycle := _initReqStepCycle;
            _sut_N.InitReqStepCycle := _initReqStepCycle;
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            IF _plcCycleCounter = 1 THEN
                _sut_A.SequencerOpen();
                _sut_N.SequencerOpen();
            END_IF

            IF _plcCycleCounter = 2 THEN
                _sut_A.SequencerOpen();
                _sut_A._RequestStep(10);
                _sut_A.SequencerClose();
                _sut_A.SequencerOpen();
                _sut_N.SequencerOpen();
                _sut_N._RequestStep(10);
                _sut_N.SequencerClose();
                _sut_N.SequencerOpen();
            END_IF

            IF _plcCycleCounter = 3 THEN
                _sut_A._Step(0, TRUE, 'Step 0');
                _sut_A._Step(20, TRUE, 'Step 20');
                _sut_A._Step(10, TRUE, 'Step 10');
                _sut_A.SequencerClose();
                _sut_N._Step(0, TRUE, 'Step 0');
                _sut_N._Step(20, TRUE, 'Step 20');
                _sut_N._Step(10, TRUE, 'Step 10');
                _sut_N.SequencerClose();
            END_IF

            IF _plcCycleCounter = 4 THEN
                _sut_A.InitReqStepCycle := _initReqStepCycle;
                _sut_N.InitReqStepCycle := _initReqStepCycle;
            END_IF

            IF _plcCycleCounter >= 5 THEN
                _sut_A.SequencerOpen();
                _sut_A.PostOpenRequestStepCycle := _sut_A.RequestStepCycle;
                _sut_A._Step(0, TRUE, 'Step 0');

                IF (_sut_A._Step(20, TRUE, 'Step 20')) THEN
                    _sut_A._RequestStep(20);
                END_IF

                IF (_sut_A._Step(10, TRUE, 'Step 10')) THEN
                    _sut_A._RequestStep(20);
                END_IF

                _sut_A.PreCloseRequestStepCycle := _sut_A.RequestStepCycle;
                _sut_A.SequencerClose();
                _sut_N.SequencerOpen();
                _sut_N.PostOpenRequestStepCycle := _sut_N.RequestStepCycle;
                _sut_N._Step(0, TRUE, 'Step 0');

                IF (_sut_N._Step(20, TRUE, 'Step 20')) THEN
                    _sut_N._RequestStep(20);
                END_IF

                IF (_sut_N._Step(10, TRUE, 'Step 10')) THEN
                    _sut_N._RequestStep(20);
                END_IF

                _sut_N.PreCloseRequestStepCycle := _sut_N.RequestStepCycle;
                _sut_N.SequencerClose();
            END_IF
        END_IF

        _sut_A.SaveNumberOfStepsInSequence();
        _sut_N.SaveNumberOfStepsInSequence();
        _sut_A.UpdateCurrentStepDetails();
        _sut_N.UpdateCurrentStepDetails();
        _done := _plcCycleCounter >= _cycles + 4;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T570_SetStepMode"}
    eTcoSequencerTests.SetStepMode:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.SetStepMode;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.SetStepMode;
            _sut_A.SetStepMode(); //Set sequencer into the step mode
            _sut_N.SetStepMode(); //Set sequencer into the step mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.ClearNumberOfSteps();
            _sut_N.ClearNumberOfSteps();
            _sut_A.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_N.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.SequenceRun := _plcCycleCounter;
            _sut_N.SequenceRun := _plcCycleCounter;

            IF _plcCycleCounter = 1 THEN
                _sut_A.Run();
                _sut_N.Run();
            END_IF

            IF _plcCycleCounter = 2 THEN
                _sut_A.SequencerOpen();
                _sut_A._StepIn();

                IF _sut_A._Step(0, TRUE, 'Initial step') THEN
                    _sut_A._StepCompleteWhen(TRUE);
                END_IF

                _sut_N.SequencerOpen();
                _sut_N._StepIn();

                IF _sut_N._Step(0, TRUE, 'Initial step') THEN
                    _sut_N._StepCompleteWhen(TRUE);
                END_IF
            END_IF

            IF _plcCycleCounter = 3 THEN
                IF _sut_A._Step(1, TRUE, 'Step 1') THEN
                    _sut_A._StepCompleteWhen(TRUE);
                END_IF

                IF _sut_N._Step(1, TRUE, 'Step 1') THEN
                    _sut_N._StepCompleteWhen(TRUE);
                END_IF

                FOR i := 2 TO _totalStepNumber - 1 DO
                    _sut_A._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i)));
                    _sut_N._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i)));
                END_FOR

                IF _sut_A._Step(_totalStepNumber, TRUE, CONCAT('Step ', INT_TO_STRING(_totalStepNumber))) THEN
                    _sut_A._SequenceComplete();
                END_IF

                IF _sut_N._Step(_totalStepNumber, TRUE, CONCAT('Step ', INT_TO_STRING(_totalStepNumber))) THEN
                    _sut_N._SequenceComplete();
                END_IF
            END_IF

            IF _plcCycleCounter = 4 THEN
                _sut_A.Run();
                _sut_N.Run();
            END_IF

            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := _plcCycleCounter >= 4;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T580_StepMode"}
    eTcoSequencerTests.StepMode:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.StepMode;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.StepMode;
            _sut_A.SetStepMode(); //Set sequencer into the step mode
            _sut_N.SetStepMode(); //Set sequencer into the step mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.ClearNumberOfSteps();
            _sut_N.ClearNumberOfSteps();
            _sut_A.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_N.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.SequenceRun := _plcCycleCounter;
            _sut_N.SequenceRun := _plcCycleCounter;
            _sut_A.Run();
            _sut_N.Run();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := _plcCycleCounter >= _totalStepNumber + 2;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T582_InvalidMode"}
    eTcoSequencerTests.InvalidMode:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.SetStepMode;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.SetStepMode;
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.SetNumberOfSteps(_totalStepNumber);
            _sut_N.SetNumberOfSteps(_totalStepNumber);
            _sut_A.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_N.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.SequenceRun := _plcCycleCounter;
            _sut_N.SequenceRun := _plcCycleCounter;

            IF _plcCycleCounter = 1 THEN
                _sut_A.SequencerOpen();
                _sut_N.SequencerOpen();

                FOR i := 0 TO _totalStepNumber - 1 DO
                    IF _sut_A._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i))) THEN
                        _sut_A._StepCompleteWhen(TRUE);
                    END_IF

                    IF _sut_N._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i))) THEN
                        _sut_N._StepCompleteWhen(TRUE);
                    END_IF
                END_FOR
            END_IF

            IF _plcCycleCounter = 2 THEN
                _sut_A._Step(_totalStepNumber, TRUE, CONCAT('Step ', INT_TO_STRING(_totalStepNumber)));
                _sut_N._Step(_totalStepNumber, TRUE, CONCAT('Step ', INT_TO_STRING(_totalStepNumber)));
                _sut_A.SequencerClose();
                _sut_N.SequencerClose();
            END_IF

            IF _plcCycleCounter = 3 THEN
                _sut_A.SequencerOpen();
                _sut_N.SequencerOpen();

                FOR i := 0 TO _totalStepNumber DO
                    _sut_A._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i)));
                    _sut_N._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i)));
                END_FOR

                _sut_A.SequencerClose();
                _sut_N.SequencerClose();
            END_IF

            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := _plcCycleCounter >= 3;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T582_StepInError"}
    eTcoSequencerTests.StepInError:
        IF NOT _arranged THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.StepInError;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.StepInError;
            _sut_A.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_N.SetCyclicMode(); //Set sequencer into the cyclic mode
            _sut_A.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_N.SetSequenceAsChecked(); //Set sequence as checked, so no StepID uniqueness is performed on next sequence execution
            _sut_A.SetNumberOfSteps(_totalStepNumber);
            _sut_N.SetNumberOfSteps(_totalStepNumber);
            _sut_A.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_N.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_A.TotalStepNumber := _totalStepNumber;
            _sut_N.TotalStepNumber := _totalStepNumber;
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            _sut_A.SequenceRun := _plcCycleCounter;
            _sut_N.SequenceRun := _plcCycleCounter;

            IF _plcCycleCounter = 1 THEN
                _sut_A.SequencerOpen();
                _sut_N.SequencerOpen();

                FOR i := 0 TO _totalStepNumber - 1 DO
                    IF _sut_A._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i))) THEN
                        _sut_A._StepCompleteWhen(TRUE);
                    END_IF

                    IF _sut_N._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i))) THEN
                        _sut_N._StepCompleteWhen(TRUE);
                    END_IF
                END_FOR
            END_IF

            IF _plcCycleCounter = 2 THEN
                _sut_A._Step(_totalStepNumber, TRUE, CONCAT('Step ', INT_TO_STRING(_totalStepNumber)));
                _sut_N._Step(_totalStepNumber, TRUE, CONCAT('Step ', INT_TO_STRING(_totalStepNumber)));
                _sut_A.SequencerClose();
                _sut_N.SequencerClose();
            END_IF

            IF _plcCycleCounter = 3 THEN
                _sut_A.SequencerOpen();
                _sut_N.SequencerOpen();

                FOR i := 0 TO _totalStepNumber DO
                    _sut_A._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i)));
                    _sut_N._Step(i, TRUE, CONCAT('Step ', INT_TO_STRING(i)));
                END_FOR

                _sut_A.SequencerClose();
                _sut_N.SequencerClose();
            END_IF

            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
        END_IF

        _done := _plcCycleCounter >= 3;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T590_CheckStepIdUniquenessStepMode"}
    eTcoSequencerTests.CheckStepIdUniquenessStepMode:
        IF NOT _arranged THEN
            _sut_A.SetStepMode(); //Set sequencer into the step mode
            _sut_N.SetStepMode(); //Set sequencer into the step mode
            _sut_A.SetSequenceAsNotChecked(); //Set sequence as not checked, so StepId uniqueness is going to be performed on next sequence run
            _sut_N.SetSequenceAsNotChecked(); //Set sequence as not checked, so StepId uniqueness is going to be performed on next sequence run
            _sut_A.ClearNumberOfSteps(); //Clear internal step counters, so number of steps is going to be counted again on next sequence run
            _sut_N.ClearNumberOfSteps(); //Clear internal step counters, so number of steps is going to be counted again on next sequence run
            _sut_A.Enabled := TRUE;
            _sut_A.RunOneStep := FALSE;
            _sut_A.RunAllSteps := TRUE;
            _sut_A.FinishStep := TRUE;
            _sut_A.StepId := _stepId;
            _sut_A.StepDescription := _stepDescription;
            _sut_N.Enabled := TRUE;
            _sut_N.RunOneStep := FALSE;
            _sut_N.RunAllSteps := TRUE;
            _sut_N.FinishStep := TRUE;
            _sut_N.StepId := _stepId;
            _sut_N.StepDescription := _stepDescription;
            _sut_A.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_N.SetCurrentStep(inStepID := _currentStepId, inStepDescription := _currentStepDescription);
            _sut_A.TcoSequencerTest := eTcoSequencerTests.CheckStepIdUniquenessStepMode;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.CheckStepIdUniquenessStepMode;
            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
            _plcCycleCounter := 0;
            _arranged := TRUE;
            RETURN;
        END_IF

        IF NOT _done THEN
            IF _plcCycleCounter = 3 THEN
                _sut_A._StepIn();
                _sut_N._StepIn();
            END_IF

            _sut_A.Run();
            _sut_N.Run();

            IF _plcCycleCounter = 4 THEN
                _sut_A.Restore();
                _sut_N.Restore();
            END_IF

            _sut_A.UpdateCurrentStepDetails();
            _sut_N.UpdateCurrentStepDetails();
            _sut_A.SaveNumberOfStepsInSequence();
            _sut_N.SaveNumberOfStepsInSequence();
        END_IF

        _done := _plcCycleCounter >= 4;

        IF _done THEN
            _sut_A.TcoSequencerTest := eTcoSequencerTests.none;
            _sut_N.TcoSequencerTest := eTcoSequencerTests.none;
        END_IF

        ProbeDoneWhen(_done);
{endregion}
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadOutCycleCounters" Id="{1913803e-85aa-00c3-3eb7-a30f031b63c4}">
      <Declaration><![CDATA[METHOD INTERNAL ReadOutCycleCounters]]></Declaration>
      <Implementation>
        <ST><![CDATA[_startCycles		:=		THIS^.StartCycleCount;
_endCycles			:=		THIS^.EndCycleCount;

_myIdentity			:= 		THIS^.Identity;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>