<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="TcoDriveSimpleTestContext" Id="{eb079fb3-48a6-04a2-0434-bd84aa928492}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK TcoDriveSimpleTestContext EXTENDS TcoCore._internals_TcoContext
VAR
    _sut : TcoDriveSimpleTest(THIS^);
    _callMyPlcInstance : BOOL := FALSE;
    _enable : BOOL;
    _enablePositive : BOOL;
    _enableNegative : BOOL;
    _calibrationCam : BOOL;
    _position : LREAL;
    _velocity : LREAL;
    _acceleration : LREAL;
    _deceleration : LREAL;
    _jerk : LREAL;	
    _inString : STRING;
    _done : BOOL;
    _arranged : BOOL;

_axisReferenceType : INT;

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="Main" Id="{a8979dcb-427e-0a51-16bc-eaf1ddb910e1}">
      <Declaration><![CDATA[METHOD PROTECTED Main
VAR 
	_retval :LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[_sut(inEnable := _enable,
    inEnablePositive := _enablePositive,
    inEnableNegative := _enableNegative,
    inCalibrationCam := _calibrationCam,
    inoAxisRef := GVL.Axis1);

CASE _testId OF
    eTcoDriveSimpleTests.Restore:
        _sut.Restore();
    eTcoDriveSimpleTests.CleanUp:
        _sut._messenger.Clear();
    {region "T003_Message"}
    eTcoDriveSimpleTests.Message:
        _sut.Messenger.Error(_inString);
        _done := _plcCycleCounter > 1;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T004_PowerDisable"}
    eTcoDriveSimpleTests.PowerDisable:
        _enable := FALSE;
        _done := _sut._axisStatus.Disabled; // OR _plcCycleCounter > 1;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T005_PowerEnable"}
    eTcoDriveSimpleTests.PowerEnable:
        _enable := TRUE;
        _done := _sut._axisStatus.Operational; // OR _plcCycleCounter > 15;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T006_Reset"}
    eTcoDriveSimpleTests.Reset:
        IF NOT _arranged THEN
            _sut.MoveRelative(inDistance := 500,
                inVelocity := 50000000,
                inAcceleration := -1,
                inDeceleration := -1,
                inJerk := -1);

            IF _sut._axisStatus.Error THEN
                _arranged := true;
            END_IF

            RETURN;
        END_IF

        _sut.Reset();
        _done := _sut.ResetTask.Done OR _sut.ResetTask.Error; // OR _plcCycleCounter > 1;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T007_MoveRelativePositiveWithDisabledPositiveDirection"}
    eTcoDriveSimpleTests.MoveRelativePositiveWithDisabledPositiveDirection:
        IF NOT _arranged THEN
            _enable := TRUE;
            _enablePositive := FALSE;
            _enableNegative := FALSE;

            IF _sut._axisStatus.Operational THEN
                _arranged := TRUE;
            END_IF

            RETURN;
        END_IF;

        _sut.MoveRelative(inDistance := _position,
            inVelocity := _velocity,
            inAcceleration := _acceleration,
            inDeceleration := _deceleration,
            inJerk := _jerk);

        _done := _sut.MoveRelativeTask.Done OR _sut.MoveRelativeTask.Error; // OR _sut._axisStatus.Error;// OR _plcCycleCounter > 5;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T008_MoveRelativePositiveWithEnabledPositiveDirection"}
    eTcoDriveSimpleTests.MoveRelativePositiveWithEnabledPositiveDirection:
        IF NOT _arranged THEN
            _enable := TRUE;
            _enablePositive := TRUE;
            _enableNegative := FALSE;

            IF _sut._axisStatus.Operational THEN
                _arranged := TRUE;
            END_IF

            RETURN;
        END_IF;

        _sut.MoveRelative(inDistance := _position,
            inVelocity := _velocity,
            inAcceleration := _acceleration,
            inDeceleration := _deceleration,
            inJerk := _jerk);

        _done := _sut.MoveRelativeTask.Done OR _sut.MoveRelativeTask.Error; // OR  _plcCycleCounter > 1000;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T009_MoveRelativeNegativeWithDisabledNegativeDirection"}
    eTcoDriveSimpleTests.MoveRelativeNegativeWithDisabledNegativeDirection:
        IF NOT _arranged THEN
            _enable := TRUE;
            _enablePositive := FALSE;
            _enableNegative := FALSE;

            IF _sut._axisStatus.Operational THEN
                _arranged := TRUE;
            END_IF

            RETURN;
        END_IF;

        _sut.MoveRelative(inDistance := _position,
            inVelocity := _velocity,
            inAcceleration := _acceleration,
            inDeceleration := _deceleration,
            inJerk := _jerk);

        _done := _sut.MoveRelativeTask.Done OR _sut.MoveRelativeTask.Error; // OR _sut._axisStatus.Error;// OR _plcCycleCounter > 5;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T010_MoveRelativeNegativeWithEnabledNegativeDirection"}
    eTcoDriveSimpleTests.MoveRelativeNegativeWithEnabledNegativeDirection:
        IF NOT _arranged THEN
            _enable := TRUE;
            _enablePositive := TRUE;
            _enableNegative := TRUE;

            IF _sut._axisStatus.Operational THEN
                _arranged := TRUE;
            END_IF

            RETURN;
        END_IF;

        _sut.MoveRelative(inDistance := _position,
            inVelocity := _velocity,
            inAcceleration := _acceleration,
            inDeceleration := _deceleration,
            inJerk := _jerk);

        _done := _sut.MoveRelativeTask.Done OR _sut.MoveRelativeTask.Error; // OR  _plcCycleCounter > 1000;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T011_HommingDirect"}
    eTcoDriveSimpleTests.HommingDirect:
        IF NOT _arranged THEN
            _enable := TRUE;
            _enablePositive := FALSE;
            _enableNegative := TRUE;

            IF _sut._axisStatus.Operational THEN
                _arranged := TRUE;
            END_IF

            RETURN;
        END_IF;

        _sut.Home(inPosition := _position,
            inHomingMode := TcoDrivesBeckhoff.eHomingMode.MC_Direct,
            inClearPositionLag := FALSE,
            inSearchDirection := TcoDrivesBeckhoff.eDirection.MC_Undefined_Direction,
            inSearchVelocity := _velocity,
            inSyncDirection := TcoDrivesBeckhoff.eDirection.MC_Undefined_Direction,
            inSyncVelocity := _velocity,
            inReferenceMode := TcoDrivesBeckhoff.eEncoderReferenceMode.ENCODERREFERENCEMODE_DEFAULT);

        _done := _sut.HomeTask.Done OR _sut.HomeTask.Error; //OR _plcCycleCounter > 1000;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T012_MoveVelocityPositiveWithDisabledPositiveDirection"}
    eTcoDriveSimpleTests.MoveVelocityPositiveWithDisabledPositiveDirection:
        IF NOT _arranged THEN
            _enable := TRUE;
            _enablePositive := FALSE;
            _enableNegative := FALSE;

            IF _sut._axisStatus.Operational THEN
                _arranged := TRUE;
            END_IF

            RETURN;
        END_IF;

        _sut.MoveVelocity(inVelocity := _velocity,
            inAcceleration := _acceleration,
            inDeceleration := _deceleration,
            inJerk := _jerk,
            inDirection := TcoDrivesBeckhoff.eDirection.MC_Positive_Direction);

        _done := _sut.MoveVelocityTask.Done OR _sut.MoveVelocityTask.Error; // OR  _sut._axisStatus.Error;// OR _plcCycleCounter > 5;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T013_MoveVelocityPositiveWithEnabledPositiveDirection"}
    eTcoDriveSimpleTests.MoveVelocityPositiveWithEnabledPositiveDirection:
        IF NOT _arranged THEN
            _enable := TRUE;
            _enablePositive := TRUE;
            _enableNegative := FALSE;

            IF _sut._axisStatus.Operational THEN
                _arranged := TRUE;
            END_IF

            RETURN;
        END_IF;

        _sut.MoveVelocity(inVelocity := _velocity,
            inAcceleration := _acceleration,
            inDeceleration := _deceleration,
            inJerk := _jerk,
            inDirection := TcoDrivesBeckhoff.eDirection.MC_Positive_Direction);

        _done := _sut.MoveVelocityTask.Done OR _sut.MoveVelocityTask.Error; // OR  _plcCycleCounter > 1000;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T014_Stop"}
    eTcoDriveSimpleTests.Stop:
        IF NOT _arranged THEN
            _enable := TRUE;
            _enablePositive := TRUE;
            _enableNegative := TRUE;

            IF _sut._axisStatus.Operational THEN
                _arranged := TRUE;
            END_IF

            RETURN;
        END_IF;

        _sut.Stop(inDeceleration := _deceleration, inJerk := _jerk);
        _done := _sut.StopTask.Done OR _sut.StopTask.Error; // OR  _plcCycleCounter > 1000;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T015_MoveVelocityNegativeWithDisabledNegativeDirection"}
    eTcoDriveSimpleTests.MoveVelocityNegativeWithDisabledNegativeDirection:
        IF NOT _arranged THEN
            _enable := TRUE;
            _enablePositive := FALSE;
            _enableNegative := FALSE;

            IF _sut._axisStatus.Operational THEN
                _arranged := TRUE;
            END_IF

            RETURN;
        END_IF;

        _sut.MoveVelocity(inVelocity := _velocity,
            inAcceleration := _acceleration,
            inDeceleration := _deceleration,
            inJerk := _jerk,
            inDirection := TcoDrivesBeckhoff.eDirection.MC_Negative_Direction);

        _done := _sut.MoveVelocityTask.Done OR _sut.MoveVelocityTask.Error; // OR  _sut._axisStatus.Error;// OR _plcCycleCounter > 5;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T016_MoveVelocityNegativeWithEnabledNegativeDirection"}
    eTcoDriveSimpleTests.MoveVelocityNegativeWithEnabledNegativeDirection:
        IF NOT _arranged THEN
            _enable := TRUE;
            _enablePositive := FALSE;
            _enableNegative := TRUE;

            IF _sut._axisStatus.Operational THEN
                _arranged := TRUE;
            END_IF

            RETURN;
        END_IF;

        _sut.MoveVelocity(inVelocity := _velocity,
            inAcceleration := _acceleration,
            inDeceleration := _deceleration,
            inJerk := _jerk,
            inDirection := TcoDrivesBeckhoff.eDirection.MC_Negative_Direction);

        _done := _sut.MoveVelocityTask.Done OR _sut.MoveVelocityTask.Error; // OR  _plcCycleCounter > 1000;
        ProbeDoneWhen(_done);
    {endregion}
    {region "T017_GetMotorType"}
    eTcoDriveSimpleTests.GetMotorType:
        IF NOT _arranged THEN
            _sut._MC_ReadDriveAddress(Axis := _sut.AxisRef, Execute := FALSE);
            _sut._fbEcCoeSdoRead(bExecute := FALSE);

            IF NOT _sut._MC_ReadDriveAddress.Error AND
                NOT _sut._MC_ReadDriveAddress.Busy AND
                NOT _sut._MC_ReadDriveAddress.Done AND
                NOT _sut._fbEcCoeSdoRead.bError AND
                NOT _sut._fbEcCoeSdoRead.bBusy THEN
                _arranged := TRUE;
            END_IF
        END_IF

        IF _arranged AND NOT _sut._MC_ReadDriveAddress.Done THEN
            _sut._MC_ReadDriveAddress(Axis := _sut.AxisRef, Execute := NOT _sut._MC_ReadDriveAddress.Busy);
            RETURN;
        END_IF

        _sut._fbEcCoeSdoRead(sNetId := _sut._MC_ReadDriveAddress.DriveAddress.NetID,
            nSlaveAddr := _sut._MC_ReadDriveAddress.DriveAddress.SlaveAddress,
            bExecute := NOT _sut._fbEcCoeSdoRead.bBusy,
            nIndex := 16#9009,
            nSubIndex := 16#02,
            pDstBuf := ADR(_sut._MotorType),
            cbBufLen := SIZEOF(_sut._MotorType));

        _sut._ftrig(CLK := _sut._fbEcCoeSdoRead.bBusy);

        IF _arranged AND _sut._ftrig.Q THEN
            _done := TRUE;
            ProbeDoneWhen(_done);
        END_IF
    {endregion}
    {region "T018_GetAxisReferenceType"}
    eTcoDriveSimpleTests.GetAxisReferenceType:
        IF NOT _arranged THEN
            _sut._MC_ReadParameter(Axis := _sut.AxisRef, Enable := FALSE);

            IF NOT _sut._MC_ReadParameter.Error AND NOT _sut._MC_ReadParameter.Busy THEN
                _arranged := TRUE;
            END_IF
        END_IF

        _sut._MC_ReadParameter(Axis := _sut.AxisRef,
            Enable := TRUE,
            ParameterNumber := TcoDrivesBeckhoff.eAxisParameter.AxisEncoderReferenceSystem,
            ReadMode := Tc2_MC2.E_ReadMode.READMODE_ONCE,
            Value =>_retval);

        _sut._ftrig(CLK := _sut._MC_ReadParameter.Busy);
        _axisReferenceType := LREAL_TO_INT(_retval);

        IF _arranged AND _sut._ftrig.Q THEN
            _done := TRUE;
            ProbeDoneWhen(_done);
        END_IF
{endregion}
END_CASE]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>